# Jwt**AuthLib Access Token Strategy**

## **Introduction**

JwtAuthLib's access token strategy is a fundamental component of its robust authentication system for Node.js applications. It revolves around the concept of JWT (JSON Web Token) and offers developers flexibility, security, and control over user authentication. This document explores the key aspects of AuthLib's access token strategy and its significance in building secure and customizable authentication mechanisms.

## **The `mapUserToJwtPayload` Function and the `sub` Property**

The **`mapUserToJwtPayload`** function is a core feature of JwtAuthLib's access token strategy. It allows developers to customize the JWT payload by providing user-specific information. The **`sub`** property (subject) is a required attribute of the JWT payload, representing the unique identifier of the authenticated user.

```tsx
type AuthInitProps = {
... //Other Configs
  **mapUserToJwtPayload: (
    user: any
  ) => { sub: string } & { [index: string]: any };**
};

//USAGE
AuthStrategy.init({
.... //Other configs 
  mapUserToJwtPayload: (user: User) => ({ sub: user._id, email: user?.email })
})
```

The uniqueness of the **`sub`** property plays a crucial role in the revoking and blacklisting of user tokens. When a user logs out or performs other actions that require token invalidation,  JwtAuthLib can efficiently revoke the specific token associated with the user's **`sub`** identifier. This ensures that even if an access token is compromised, it can be invalidated and rendered useless, bolstering the security of the application.

## **Flexibility and Universality in Subject Handling**

JwtAuthLib's approach to subject handling provides developers with unparalleled flexibility. The ability to pass any subject, regardless of the technology stack being used, allows for seamless integration of the library into diverse applications. Developers are not bound to specific user identifier formats, granting them the freedom to use UUIDs, usernames, email addresses, or any other unique identifier as the JWT subject.

## **Role of Login and Register Validation in JWT Generation**

Login and register validation are pivotal steps in the JWT generation process. JwtAuthLib's access token strategy relies on these validations to ensure that only legitimate users are issued valid tokens. During the login and registration processes, custom validation functions can be provided by developers to verify user credentials and authorize access.

```tsx
type ValidateFn = (body: any, done: (user: any, err: any) => void) => void;

// to validate Login
useLoginValidate(validateFn: ValidateFn){}; //called for /login auth route

// to validate registeration 
useRegisterValidate(validateFn: ValidateFn){} //called for /register auth route

```

```tsx
//USAGE 
const AuthStrategy = new AuthLib();

AuthStrategy.init({
  redisUrl: APP_CONFIG.REDIS_URL,
  mapUserToJwtPayload: (user: User) => ({ sub: user._id, email: user?.email }),
  jwtConfig: {
    accessTokenSecret: APP_CONFIG.JWT_ACCESS_TOKEN_SECRET,
    refreshTokenSecret: APP_CONFIG.JWT_REFRESH_TOKEN_SECRET,
    expiresIn: {
      access: "1d",
      refresh: "7d",
    },
    issuer: "api.ayo.xyz",
    audience: ["ayo.xyz"],
  },
});

AuthStrategy.useLoginValidate((loginInfo: LoginPayload, done) => {
  userDb.findOne({ email: loginInfo.email }, (err, existingUser) => {
    if (err) return done(null, err);
    if (!existingUser) return done(null, "Password/Email Mismatch");
    if (existingUser?.password !== loginInfo?.password) {
      return done(null, "Invalid Credentials");
    }
    done(existingUser, null);
  });
});

AuthStrategy.useRegisterValidate((newUser: RegisterPayload, done) => {
  userDb.findOne({ email: newUser?.email }, (err, existingUser) => {
    if (err) {
      return done(null, err);
    }
    if (existingUser) {
      return done(null, "User Already Exists");
    }
    userDb.insert(newUser, (err, doc) => {
      if (err) {
        return done(null, err);
      }
      done(doc, null);
    });
  });
});

```

Without robust login and register validation, the JWTs generated by JwtAuthLib would lack the necessary security guarantees, making the entire authentication system vulnerable to unauthorized access.

JwtAuthLib exposes express Handlers that calls this validation methods, the handlers are

```tsx
handleLogin = (req: Request, res: Response, next: NextFunction) => {
// ...login valdation method calls and other checks
return res.status(201).json({
        user,
        accessToken,
        refreshToken,
  });
}

handleRegister = (req: Request, res: Response, next: NextFunction) => {
 //...registeration valdation method calls and other checks
return res.status(201).json({
        user,
        accessToken,
        refreshToken,
  });
}
```

**USAGE OF Handlers**

```tsx
import express, { Express } from "express";
const app = express();

// Handle login route
app.post("/auth/login", authLib.handleLogin);

// Handle registration route
app.post("/auth/register", authLib.handleRegister);
```

## **Customization of Token Expiration, Audience, and Issuers**

JwtAuthLib empowers developers to set specific token expiration limits, audience, and issuer information within the JWT payload. This customization ensures that the tokens meet the application's unique requirements and adhere to security best practices. By defining expiration times, audiences, and issuers, developers can control the validity period and scope of the tokens.

this is done in the `jwtConfig` argument passed to initialize a JwtAuthLib instance

```tsx
type JWT_CONFIG = {
  refreshTokenSecret: string;
  accessTokenSecret: string;
  expiresIn: {
    refresh: string;
    access: string;
  };
  issuer: string;
  audience: string | string[];
};
```

```tsx
//USAGE 
const AuthStrategy = new AuthLib();

AuthStrategy.init({
 ... //Other Configs her
  jwtConfig: {
    accessTokenSecret: APP_CONFIG.JWT_ACCESS_TOKEN_SECRET,
    refreshTokenSecret: APP_CONFIG.JWT_REFRESH_TOKEN_SECRET,
    expiresIn: {
      access: "1d",
      refresh: "7d",
    },
    issuer: "api.ayo.xyz",
    audience: ["ayo.xyz"],
  },
});
```

`JwtConfig.expiresIn` values uses `ms` library format.

[npm: ms](https://www.npmjs.com/package/ms)

## **Importance of `useJwtValidate` validation method**

The `useJwtValidate`  is a critical component for users of JwtAuthLib's access token strategy. It ensures that the subject in a JWT at the time of the request is still associated with a valid user. This method, executed for every authenticated request, verifies the integrity and legitimacy of the token and prevents unauthorized access to protected resources.

```tsx
useJwtValidate(
    validateFn: (jwtPayload: any, done: (user: any, err: any) => void) => void
  ) {
    this.validateFns["jwt"] = validateFn;
}
```

```tsx
//USAGE
AuthStrategy.useJwtValidate(({ sub }: { sub: string; email: string }, done) => {
  userDb.findOne({ _id: sub }, (err, doc) => {
    if (err) {
      return done(null, "Please Login");
    }
    done(doc, null);
  });
});
```

## **Authenticated Handlers for Access Token Validation and Revocation**

**JwtAuthLib** provides essential authenticated handlers that play a vital role in validating access tokens and revoking them. When a request is made, the access token is authenticated using the `useJwtValidate`  Method. Additionally, if a user logs out or needs their token invalidated, the access token is stored in Redis as a blacklisted token. JwtAuthLib checks against Redis to ensure that even though a token may not have expired, it is not blacklisted, thus providing an extra layer of security against compromised tokens.

```tsx
//jwtAuthLibHandlers

//handles protected route
authenticateJwt(
    jwtExtractor: (
      request: Request
    ) => string | null = Extractor.fromAuthHeaderAsBearerToken()
  ) {}

//handles refresh token route
handleRefreshToken(
    jwtExtractor: (
      request: Request
    ) => string | null = Extractor.fromAuthHeaderAsBearerToken()
  ){}

//handles revoke access token
handleRevokeAccessToken(
    jwtExtractor: (
      request: Request
    ) => string | null = Extractor.fromAuthHeaderAsBearerToken()
  ) {}
```

**JwtAuthLib** Auth Handlers

each handler expects an extractor method, you can provide a custom extractor method, or make use of the Extractor class, you can read more on the extractor class here [Token Extraction Utils](https://github.com/ogheneovo12/auth-lib/blob/main/Extractor.md) 

**Usage Of JwtAuthLib auth Handlers**

```tsx
//Usage of Handlers

// Protect a route using authenticateJwt middleware
app.get("/protected", authLib.authenticateJwt(), (req, res) => {
  // The authenticated user's information can be accessed using req.user
  res.json({ user: req.user });
});

// Handle refresh token route
app.post("/auth/refresh", authLib.handleRefreshToken());

// Handle Logout Route
app.post("/auth/logout", authLib.handleRevokeAccessToken());
```

## **Conclusion**

**JwtAuthLib's** access token strategy offers a comprehensive and secure approach to user authentication in Node.js applications. From the customizable JWT payload and flexible subject handling to the importance of login and register validation, developers can create robust and secure authentication systems tailored to their specific needs. The ability to set token expiration, audience, and issuer information further enhances the security and scope of the access tokens. With the `useJwtValidate` and authenticated handlers, **JwtAuthLib** ensures that every authenticated request is validated and secure, providing a seamless and reliable authentication experience for users.
